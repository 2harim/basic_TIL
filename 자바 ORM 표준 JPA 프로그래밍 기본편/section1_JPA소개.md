**목차**
- [👿 SQL 중심적인 개발의 문제점](#sql-중심적인-개발의-문제점)
  - [1. 무한 반복, 지루한 코드](#1-무한-반복-지루한-코드)
  - [2. 패러다임 불일치](#2-패러다임-불일치)
- [👋 JPA 소개](#jpa-소개)
  - [ORM](#orm)
  - [JPA 동작 - 저장](#jpa-동작---저장)
  - [JPA 소개](#jpa-소개-1)
  - [JPA 왜 사용해야 하는가?](#jpa-왜-사용해야-하는가)
  - [JPA 성능 최적화 기능](#jpa-성능-최적화-기능)

<br>

## 👿 SQL 중심적인 개발의 문제점

### 1. 무한 반복, 지루한 코드

애플리케이션 개발 : 보통 객체 지향 언어(java, Scala, C# ,..) 

데이터베이스 : 관계형 DB(Oracle, MySQL, ..)

객체를 관계형 DB에 관리 → SQL 의존적인 개발 피하기 어려움

<br>

### 2. 패러다임 불일치

객체 지향 프로그래밍 : 추상화, 캡슐화, 정보은닉, 상속, 다형성 등

객체를 RDB에 저장하려면

```mermaid
graph LR;
nID1[객체] --> nID2[SQL 변환];
nID2[SQL 변환] --> |SQL| RDB;
```

<br>

**객체 지향 프로그래밍과 관계형 DB 차이점**

- 상속
    
    테이블에 상속 관계 X → `슈퍼타입 서브타입 관계` 로 설계
    
    객체를 저장/조회하기 위해 객체를 분해하고 여러 insert 문 작성 필요 😠
    
- 연관관계
    
    객체는 `참조` 사용  ex) `member.getTeam()`
    
    테이블은 `외래 키` 사용  ex) `join on m.table_id = t.table_id`
    
    참조로 연관관계 맺지 못하지 때문에 객체 다운 모델링 X
    
    객체는 자유롭게 객체 그래프 탐색 가능
    
    DB는 SQL에 따라 탐색 범위 결정
    

객체답게 모델링 할수록 매핑 작업이 늘어남

객체를 자바 컬렉션에 저장하듯 DB에 저장할 수 있는 방법?!

⇒ JPA

<br>

## 👋 JPA 소개

Java Persistence API 

자바 진영 ORM 기술 표준

<br>

### ORM

Object-relational mapping 객체 관계 매핑

객체는 객체대로 설계, RDB는 RDB대로 설계

*ORM 프레임워크가 중간에서 매핑*

JPA는 **애플리케이션**과 **JDBC** 사이에서 동작

![Untitled](/img/jpa_basic/section1/jpa.png)

<br>

### JPA 동작 - 저장

![Untitled](/img/jpa_basic/section1/jpa_save.png)

JPA가 알아서 entity 분석해서 SQL문 만들어줌 

<br>

### JPA 소개

1. EJB → 엔티티 빈(너무 복잡하고 성능 낮아서 대부분 개발자 사용 X)
2. 하이버네이트(오픈소스) 
3. JPA(자바 표준)

> *오픈소스는 빠르게 만듦
자바 표준은 여러 사람이 모여 결정하기 때문에 좀 더 용어 등에서 정교함*
> 

<br>

**JPA는 표준 명세**

인터페이스 모음

JPA2.1 표준 명세를 구현한 3가지 구현체 - Hibernate(90%↑), EclipseLink, DataNucleaus

<br>

### JPA 왜 사용해야 하는가?

- SQL 중심적인 개발 → **객체 중심으로 개발**
    
    개발자는 마치 Collection에 저장하듯이 사용하면 됨
    
- 생산성
    
    ![Untitled](/img/jpa_basic/section1/jpa_method.png)
    
- 유지보수
    
    필드 변경시 예전에는 모든 SQL 문을 변경했어야 함
    
    JPA 사용시 필드만 추가하면 됨
    
- 패러다임 불일치 해결
    
    상속 - 메서드 이용해서 넣어주기만 하면 알아서 JPA가 SQL문 생성
    
    연관관계 - 참조 사용 가능, `member.getTeam()` 해서 team 꺼내올 수 있음
    
    객체 그래프 탐색
    
    JPA 비교 - 동일한 트랜잭션에서 조회한 엔티티는 같음을 보장함
    
<br>

### JPA 성능 최적화 기능

- **1차 캐시와 동일성 보장**
    
    같은 트랜잭션에서 같은 엔티티 반환 → 약간의 조회 성능 향상
    
    처음에는 SQL문 날려서 데이터 조회해서 가져오는데 두 번째 조회할 때는 SQL문 날리지 않고 JPA가 가지고있는 메모리 상에서 찾아서 반환
    
- **트랜잭션 지원하는 쓰기 지연**
    
    트랜잭션 커밋 전까지는 INSERT SQL문을 모아둠
    
    JDBC BATCH SQL 기능을 사용해서 한번에 SQL 전송 → 네트워크 통신 비용 줄어듦
    
- **지연 로딩과 즉시 로딩**
    
    `지연 로딩` : 객체 실제 사용될 때 로딩
    
    member 사용할 때마다 team을 사용하면 항상 같이 가져오는게 좋음
    
    하지만 어쩌다가 한 번 team이 필요하면 연관관계를 미리 가져올 필요가 없음
    
    `즉시 로딩` : JOIN SQL로 한 번에 연관된 객체까지 미리 조회