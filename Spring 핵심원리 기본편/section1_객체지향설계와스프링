# 1 객체 지향 설계와 스프링
  - [❄️ 자바 진영의 추운 겨울과 스프링의 탄생](#️자바-진영의-추운-겨울과-스프링의-탄생)
    - [스프링](#스프링)
  - [🌱 스프링이란?](#스프링이란)
    - [스프링 프레임워크](#스프링-프레임워크)
    - [스프링 부트](#스프링-부트)
    - [그래서 스프링이란?](#그래서-스프링이란)
    - [왜 만들었을까?](#왜-만들었을까)
  - [🧱 좋은 객체 지향 프로그래밍](#좋은-객체-지향-프로그래밍)
    - [객체 지향 프로그래밍](#객체-지향-프로그래밍)
    - [다형성 비유](#다형성-비유)
    - [자바 언어의 다형성](#자바-언어의-다형성)
    - [다형성 본질](#다형성-본질)
  - [🚧 좋은 객체 지향 설계의 5가지 원칙 SOLID](#좋은-객체-지향-설계의-5가지-원칙-solid)
    - [SRP 단일 책임 원칙](#srp-단일-책임-원칙)
    - [OCP 개방-폐쇄 원칙](#ocp-개방-폐쇄-원칙)
    - [LSP 리스코프 치환 원칙](#lsp-리스코프-치환-원칙)
    - [ISP 인터페이스 분리 원칙](#isp-인터페이스-분리-원칙)
    - [DIP 의존관계 역전 원칙](#dip-의존관계-역전-원칙)
  - [🫧 객체 지향 설계와 스프링](#객체-지향-설계와-스프링)
    - [정리](#정리)
    - [실무 고민](#실무-고민)

<br>


## ❄️ 자바 진영의 추운 겨울과 스프링의 탄생

2000년 초반 자바 진영 표준 기술 중 가장 많이 사용하는 **EJB(Enterprise Java Beans)** 존재

보급이 일반화되어 있었음 ex) 금융권

👍 장점 : 컨테이너, 설정에 의한 transaction 관리, 분산 기술, 엔티티빈 ORM 기술

👎 단점 : 매우 비쌈, 복잡하고 어렵고 느렸음, EJB에 의존적으로 개발해야 함

<br>

→ 순수한 옛날 자바로 돌아가자 **(POJO)**

<br>

→ **스프링 & 하이버네이트 등장**

- 스프링 : EJB 컨테이너 대체, 단순
- 하이버네이트 : EJB 엔티티빈 기술 대체 ⇢ JPA 새로운 표준 정의

```
📢  표준 인터페이스 - JPA
    JPA 구현체들 - 하이버네이트, EclipseLink, ..
```

<br>

### 스프링

- EJB 문제점을 지적
- BeanFactory, ApplicationContext, POJO, IoC, DI, ..

**릴리즈**

| 2003. 스프링 1.0 | XML 설정 |
| --- | --- |
| 2006. 스프링 2.0 | XML 편의 기능 지원 |
| 2009. 스프링 3.0 | 자바 코드로 스프링 설정(XML 없이 가능) |
| 2013. 스프링 4.0 | Java8 지원 |
| 2014. 스프링 부트 1.0 | 설정 간편해짐, Tomcat 내장  |
| 2017. 스프링 5.0, 스프링 부트 2.0 | 리액티브 프로그래밍 지원(비동기 넌블로킹 가능) |

<br>

---

## 🌱 스프링이란?

여러 기술의 모음

> *스프링 프레임워크, 스프링 부트 <br>
스프링 데이터, 스프링 세션, 스프링 시큐리티, 스프링 Rest Docs, 스프링 배치, 스프링 클라우드*
> 

[스프링 공식 문서](https://spring.io/)

<br>

### 스프링 프레임워크

- **핵심 기술** : 스프링 DI 컨테이너, AOP, 이벤트, ..
- **웹 기술** : 스프링 MVC, 스프링 WebFlux
- **데이터 접근 기술** : 트랜잭션, JDBC, ORM 지원, XML 지원
- **기술 통합** : 캐시, 이메일, 원격접근, 스케줄링
- **테스트** : 스프링 기반 테스트 지원
- **언어** : 코틀린, 그루비

<br>

### 스프링 부트

- 스프링 편리하게 사용할 수 있도록 지원, 실무 프로젝트에서 많이 사용
- 단독으로 실행할 수 있는 스프링 애플리케이션 쉽게 생성
- 웹 서버 내장 (Tomcat)
- starter 종속성 제공 **→ 빌드 구성 easy, 필요 라이브러리를 편하게 가져옴**
- 스프링과 외부 라이브러리 자동 구성 **→ 스프링과의 버전 맞춤 자동**
- 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공 **→ 모니터링 기본 제공**
- 관례에 의한 간결한 설정 **→ 필요한 부분만 custom하면 됨**

> ※ 스프링부트는 스프링 프레임워크와 별도로 사용하는 것이 아님! 중간에서 편리하게 사용할 수 있는 기능을 제공하는 것

<br>

### 그래서 스프링이란?

문맥에 따라 다르게 사용

- 스프링 DI 컨테이너 기술
- 스프링 프레임워크
- 스프링 부트, 스프링 프레임워크 등을 모두 포함한 스프링 생태계

<br>

### 왜 만들었을까?

핵심 컨셉 : 자바 언어 기반의 프레임워크 → 객체 지향

스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있도록 도와주는 프레임워크

<br>

---

## 🧱 좋은 객체 지향 프로그래밍

<br>

### 객체 지향 프로그래밍

> 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 **“객체”들의 모임**으로 파악하고자 하는 것, 각각의 객체는 메시지를 주고받고 데이터 처리할 수 있음
<br>
프로그램을 **유연하고 변경이 용이**하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용

컴포넌트를 쉽고 유연하게 변경하면서 개발하는 것! ⇒ **다형성 Polymorphism**

<br>

### 다형성 비유

**역할**과 **구현**으로 세상 구분

![Untitled](./../img/polymorphism.png)

자동차 **인터페이스**에 맞게 구현을 했기 때문에 자동차를 바꾼다고 운전면허를 바꿀 필요 없음
운전자는 역할에 대해서만 의존하고 있음

역할과 구현을 분리한 이유는 운전자 즉 **클라이언트**를 위함
클라이언트는 내부 구조를 몰라도 됨, 내부가 변경이 되더라도 자동차 역할만 하고 있다면 영향을 주지 않음
구현 대상 자체를 변경해도 영향 X

**⇒ 단순, 유연, 변경 용이**

<br>

객체 설계시 역할과 구현 명확히 분리함 → 역할(인터페이스) 먼저 부여하고 역할 수행하는 구현 객체 생성

<br>

### 자바 언어의 다형성

**오버라이딩**된 메서드 실행

```
interface 타입의 메소드를 실행하면 실제로 구현체에 맞는 메소드를 실행함
다형성으로 인터페이스를 구현한 객체를 실행 시점에 유연하게 변경할 수 있음
```

<br>

### 다형성 본질

인터페이스 구현한 객체 인스턴스를 실행 시점에 유연하게 변경 가능

클라이언트를 변경하지 않고 서버의 구현 기능을 유연하게 변경할 수 있다

역할 자체가 변하면 클라이언트, 서버 모두 큰 변경 발생 → 인터페이스를 안정적으로 잘 설계하는 것이 중요

<br>

---

## 🚧 좋은 객체 지향 설계의 5가지 원칙 SOLID

<br>

### SRP 단일 책임 원칙

- 한 클래스는 하나의 책임만 가져야 함

책임이란?

> 문맥과 상황에 따라 다름
판단 기준은 변경! 변경이 있을 때 파급 효과가 적으면 SRP 잘 따른 것
ex) UI 변경, 객체 생성과 사용 분리
> 

<br>

### OCP 개방-폐쇄 원칙

- 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다
- 다형성 활용

```jsx
MemberRepository m = new MemoryMemberRepository(); //기존 코드
MemberRepository m = new JdbcMemberRepository(); //변경 코드
```

구현 객체를 변경하려면 클라이언트 코드 변경 필요함 → 다형성 활용했지만 OCP 원칙 지킬 수 없음 🥲

⇒ 객체 생성하고 연관관계 맺어주는 별도의 **설정자** 필요

<br>

### LSP 리스코프 치환 원칙

- 프로그램 객체는 프로그램의 정확성 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 함
- 다형성에서 하위 클래스는 인터페이스 규약을 지켜야 함
ex) 자동차에서 엑셀은 앞으로 가능 기능 → 뒤로 가게 구현하면 LSP 원칙 위반 😡

<br>

### ISP 인터페이스 분리 원칙

- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다
- 좀 더 구체적으로 분리 → 클라이언트도 분리됨, 하나의 인터페이스 자체가 변해도 다른 클라이언트에 영향 주지 않음
- 인터페이스 명확해지고 대체 가능성 높아짐

<br>

### DIP 의존관계 역전 원칙

- 프로그래머는 추상화에 의존해야하지, 구체화에 의존하면 안된다 
즉 클라이언트가 구현 클래스가 아닌 인터페이스에 의존해야 한다는 의미
- **역할**에 의존하는 것과 같은 말

```jsx
private MemberRepository memberRepository = new MemoryMemberRepository();
```

여기서 memberRepository는 인터페이스에 의존하지만 구현 클래스도 동시에 의존함 → DIP 위반

<br>

객체 지향의 핵심은 다형성 

하지만 다형성만으로는 OCP, DIP 지킬 수 없음 

<br>

---

## 🫧 객체 지향 설계와 스프링

<br>

스프링에서는 DI, DI 컨테이너, .. 기술을 통해 OCP, DIP 지원

→ 클라이언트 코드 변경 없이 기능 확장이 가능함

<br>

### 정리

- 모든 설계에 역할과 구현을 분리해야 함
- 애플리케이션 설계도 공연 설계 하듯 배역만 두고 배우는 언제든지 유연하게 변경할 수 있도록 하는 것이 좋은 객체 지향 설계
- 이상적으로는 모든 설계에 인터페이스 부여하자

<br>

### 실무 고민

- 인터페이스 도입하면 추상화 비용이 발생 → 개발자가 코드를 한 번 더 열어봐야 함(구현 클래스가 안보임)
- 기능을 확장할 가능성이 없다면 구체 클래스 직접 사용하고 향후 필요할 때 리팩터링해서 인터페이스 도입하는 것도 방법